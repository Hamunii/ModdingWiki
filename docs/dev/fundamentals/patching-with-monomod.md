---
prev: true
next: false
description: Learn how to use MonoMod for patching the game's code.
---

# Patching with MonoMod
## Introduction
When modding games, you will often need to make modifications to the original code. Thankfully, this is fairly easy thanks to **MonoMod** and **Harmony**. This article will teach you how to use MonoMod for patching.

### Why MonoMod
Let's first go through what makes MonoMod so great. While both MonoMod and Harmony are powerful tools, one could argue MonoMod is easier to use thanks to its `MMHOOK` assemblies generated by **MonoMod.RuntimeDetour.HookGen**.

If you've ever wondered what [HookGenPatcher](https://thunderstore.io/c/lethal-company/p/Evaisa/HookGenPatcher/) is, it generates these files from its target assemblies using the HookGen API. For example, `Assembly-CSharp.dll` is the assembly that contains most of the game's code, and MonoMod's HookGen generates a file from it called `MMHOOK_Assembly-CSharp.dll`, which provides us an easy way to **Hook** any non-generic method as if it were an **event**.

To use these events, we can for example do the following:
```cs
On.StartOfRound.Awake += MyPatch;
```
This will add our method `MyPatch` as an event handler for the `Awake` event in the `StartOfRound` class, under the `On` namespace. The `Awake` event is invoked when the original `Awake` method runs.

#### Basics
**Subscribing and Unsubscribing from Events in C#**

In case events in C# are new to you, we'll go through the basics of how to work with them.  
**To subscribe to an event**, we use the addition assignment operator (`+=`).  
**To unsubscribe from an event**, we use the subtraction assignment operator (`-=`).

Our **event handler** goes to the right side of the operator, and is a method that takes in the arguments given by the event we are subscribing to. In our earlier example, we subscribed `MyPatch` to the `On.StartOfRound.Awake` event. This event passes the original method `On.StartOfRound.orig_Awake orig` and an instance of the object `StartOfRound self` as arguments. Thankfully, we can let our IDE generate the method for us *(from e.g. `quick fix` -> `Generate Method 'MyPatch'` in Visual Studio Code)* so we don't need to define it ourselves. This will generate the the following method:
```cs
private void MyPatch(On.StartOfRound.orig_Awake orig, StartOfRound self)
{
    throw new NotImplementedException();
}
```
However, currently this will just throw an exception and the original method will not run. Let's fix that:
```cs
private void MyPatch(On.StartOfRound.orig_Awake orig, StartOfRound self)
{
    throw new NotImplementedException(); // [!code --] // [!code focus]
    orig(self); // [!code ++] // [!code focus]
}
```
What we just did is call the original method `orig` with the arguments it takes, which is just `self`. If it had more arguments, we would also pass them in the `orig` call, e.g. `orig(self, arg2, arg3);`. The reason why `self` is an argument is because the method we are patching is not static meaning it has an instance, which is what `self` is.

With `self`, we can access and manipulate the variables of the GameObject, which in this case would be an instance of `StartOfRound`. Now we have gone through the basics, and we will move on to examples.

## Examples
### Hooks
#### Infinite Sprint Patch
One of the easiest patches you can do is an infinite sprint patch by setting sprint meter to full every frame. Here we have hooked `PlayerControllerB`'s `Update` method which runs every frame. In the Hook, we run the original method, and then set `sprintMeter` to `1`. In this case it doesn't really matter if our code runs before or after the original method, because this is such a simple patch.
```cs
// Somewhere in our code we subscribe to the event once:
On.GameNetcodeStuff.PlayerControllerB.Update += PlayerControllerB_Update;
// ...
private void PlayerControllerB_Update(On.GameNetcodeStuff.PlayerControllerB.orig_Update orig, GameNetcodeStuff.PlayerControllerB self)
{
    orig(self);
    self.sprintMeter = 1;
}
```
### ILHooks
ILHooks are a way to modify the original methods on the IL level, which is what C# compiles to. This is how we can have full control over what the original method does.

ILHooks are harder to do than normal Hooks, and should generally only be used if there is a reason to, since normal Hooks can provide better compatiblity with other mods since they don't modify the IL code. For example if two mods try to modify the same IL code, it could lead into an incompatibility between them.

If you are making a Hook that doesn't call the original method but instead reimplements most of it, you should use an ILHook instead, as not calling the original method is an easy way to break compatiblity with other mods.

For a list of IL instructions, see [the Wikipedia page](https://en.wikipedia.org/wiki/List_of_CIL_instructions) or [Microsoft documentation](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=net-8.0#fields) on them.

Relevant resources: [IL Hooking - RoR2 Modding Wiki](https://risk-of-thunder.github.io/R2Wiki/Mod-Creation/C%23-Programming/IL-Hooking/)

#### My First ILHook
Let's say we want to make the following modification to the jumping behavior in the game:  
*When running, the character should perform much bigger jumps.*

To do this, we must know that the variable `jumpForce` of `PlayerControllerB` affects how strong jumps are, so let's try making a normal Hook to change it depending on whether or not we are sprinting:

```cs
On.GameNetcodeStuff.PlayerControllerB.Update += PlayerControllerB_Update;
// ...
private void PlayerControllerB_Update(On.GameNetcodeStuff.PlayerControllerB.orig_Update orig, GameNetcodeStuff.PlayerControllerB self)
{
    orig(self);
    if (self.isSprinting)
        self.jumpForce = 30f;
    else
        self.jumpForce = 13f;
}
```
However, the above code doesn't quite give the results we wish for.
This is because `jumpForce` is used when calculating fall speed, and changing it happens to affect how fast we will fall.

There are many ways to work around this, and one way to make sure it is only changed when jumping is to use an ILHook. We will move the above logic to only run when the `Jump_performed` method is run and the player is allowed to jump.

The decompiled `Jump_performed` method will look something like this:
```cs
private void Jump_performed(InputAction.CallbackContext context)
{
    if (!quickMenuManager.isMenuOpen && ((base.IsOwner && isPlayerControlled && (!base.IsServer || isHostPlayerObject)) || isTestingPlayer) && !inSpecialInteractAnimation && !isTypingChat && (isMovementHindered <= 0 || isUnderwater) && !isExhausted && (thisController.isGrounded || (!isJumping && IsPlayerNearGround())) && !isJumping && (!isPlayerSliding || playerSlidingTimer > 2.5f) && !isCrouching)
    {
        // <-- We want to execute our code here
        playerSlidingTimer = 0f;
        isJumping = true;
        sprintMeter = Mathf.Clamp(sprintMeter - 0.08f, 0f, 1f);
        movementAudio.PlayOneShot(StartOfRound.Instance.playerJumpSFX);
        if (jumpCoroutine != null)
        {
            StopCoroutine(jumpCoroutine);
        }
        jumpCoroutine = StartCoroutine(PlayerJump());
    }
}
```
As we can see, if we used a normal Hook, there are many expressions we would have to copy from the if statement into our code for it to work as intended. And if another mod modifes these expressions, our mod will not get these changes because we would have just reimplemented the code instead. Alternatively we could try hooking the `PlayerJump` method, but it is a coroutine, which need special treatment to be hooked "properly".

The above method in IL with the place we are wanting to execute our code looks like this:
```IL
// ...
IL_00a7: ldarg.0    // load argument 0 'this' onto stack
IL_00a8: ldfld bool GameNetcodeStuff.PlayerControllerB::isCrouching
// Push the value of 'isCrouching' onto the stack. 
IL_00ad: brtrue.s IL_011d // Branch to IL_011d if value from stack is non-zero (true)

// <-- We want to execute our code here

IL_00af: ldarg.0        // load argument 0 'this' onto stack
IL_00b0: ldc.r4 0.0     // push 0 onto the stack as float32
IL_00b5: stfld float32 GameNetcodeStuff.PlayerControllerB::playerSlidingTimer
// replace the value of 'playerSlidingTimer' with value from stack

IL_00ba: ldarg.0        // load argument 0 'this' onto stack
IL_00bb: ldc.i4.1       // Push 1 onto the stack as int32
IL_00bc: stfld bool GameNetcodeStuff.PlayerControllerB::isJumping
// replace the value of 'isJumping' with value from stack
// ...
```
Now we know the place in IL where we want to insert our code inside the original method, so let's write our ILHook:
```cs
IL.GameNetcodeStuff.PlayerControllerB.Jump_performed += PlayerControllerB_Jump_performed;
// ...
private void PlayerControllerB_Jump_performed(ILContext il)
{
    ILCursor c = new(il);

    // Find a place inside the if statement which makes us jump.
    // We know the following C# line is inside the if statement:
    // this.playerSlidingTimer = 0f;
    // So we locate it from IL code:
    c.GotoNext(
        // IL_00af: ldarg.0         // load argument 0 'this' onto stack
        // IL_00b0: ldc.r4 0.0      // push 0 onto the stack as float32
        // IL_00b5: stfld float32 GameNetcodeStuff.PlayerControllerB::playerSlidingTimer // replace the value of 'playerSlidingTimer' with value from stack
        x => x.MatchLdarg(0),
        x => x.MatchLdcR4(0.0f),
        x => x.MatchStfld<PlayerControllerB>("playerSlidingTimer")
        // The reason we have multiple things to match is to make sure
        // that even if the original IL code changes, we will find the
        // exact place if it still exists. If GotoNext doesn't match everything,
        // it will throw an exception and this code won't run.
        // If you don't want it to throw an exception, use TryGotoNext instead.
    );
    // Our IL cursor is now located before the first intruction we matched againts in GotoNext.
    // The IL cursor will always be between an above and below instruction.
    // If we want to move it, we could for example do c.Index += 3; to move it after the stfld instruction.
    
    // To instert our C# logic from before, we will do the following:
    // We will emit a delegate Method of type void (Action) which
    // takes an instance of PlayerControllerB as an argument.
    // Because this is IL code, we have to load 'this' (PlayerControllerB) onto
    // stack first, with ldarg.0
    c.Emit(OpCodes.Ldarg_0); // load argument 0 'this' onto stack
    // Any non-static method has 'this' as the first argument
    c.EmitDelegate<Action<PlayerControllerB>>((self) =>
    {
        Plugin.Logger.LogInfo("Hello from C# code in IL!");

        if (self.isSprinting)
            self.jumpForce = 30f;
        else
            self.jumpForce = 13f; // this is the default value of jumpForce
    });
    // Plugin.Logger.LogInfo(il.ToString()); // uncomment to print the modified IL code to console
}
```
We have now made our first ILHook! While takes a bit of knowledge to get here, in the end it is not too compliated. As long as you keep a List of IL instructions on you to know which instructions do what exactly, you can get quite far without needing help.

The hard part about ILHooking is that it is very easy to emit invalid IL code, which will immediately result in an error. For example, if we didn't do `c.Emit(OpCodes.Ldarg_0);` before `EmitDelegate`, it would lead to an error. And this is because our Delegate method takes an instance of `PlayerControllerB` as an argument.

#### Replacing a Method Call

::: info
The following ILHook example is taken from the [JetpackFallFix](https://thunderstore.io/c/lethal-company/p/Hamunii/JetpackFallFix/) mod.
:::
In `PlayerControllerB`, there is an if statement which checks for collision when flying with the jetpack. However, this method call is mistakenly missing an argument which tells the check to ignore trigger colliders, meaning you can take damage with the jetpack when colliding with random trigger colliders, in air.

The following ILHook replaces this method call: 
```cs
Physics.CheckSphere(this.gameplayCamera.transform.position, 3f, StartOfRound.Instance.collidersAndRoomMaskAndDefault) // [!code --]
Physics.CheckSphere(this.gameplayCamera.transform.position, 3f, StartOfRound.Instance.collidersAndRoomMaskAndDefault, QueryTriggerInteraction.Ignore) // [!code ++]
```
```cs
IL.GameNetcodeStuff.PlayerControllerB.Update += PlayerControllerB_Update;
// ...
private static void PlayerControllerB_Update(ILContext il)
{
    /*
    // Find:

    if (Physics.CheckSphere(this.gameplayCamera.transform.position, 3f, StartOfRound.Instance.collidersAndRoomMaskAndDefault))
    
    // And add QueryTriggerInteraction.Ignore at the end of CheckSphere().
    // This prevents us from colliding with trigger colliders when flying with the jetpack.
    */

    ILCursor c = new(il);
    c.GotoNext(
        x => x.MatchLdarg(0),
        x => x.MatchLdfld<PlayerControllerB>("gameplayCamera"),
        x => x.MatchCallvirt<Component>("get_transform"),
        x => x.MatchCallvirt<Transform>("get_position"),
        x => x.MatchLdcR4(3),
        x => x.MatchCall<StartOfRound>("get_Instance"),
        x => x.MatchLdfld<StartOfRound>("collidersAndRoomMaskAndDefault"),
        x => x.MatchCall<Physics>("CheckSphere")
    );
    c.Index += 7;               // Position us before CheckSphere
    c.Remove();                 // Remove original call to CheckSphere
    c.Emit(OpCodes.Ldc_I4_1);   // Push QueryTriggerInteraction.Ignore (1) onto stack
    c.Emit(                     // And call the version of CheckSphere which takes QueryTriggerInteraction as an argument 
        OpCodes.Call, typeof(Physics)
        .GetMethods()
        .Where(x => x.Name == "CheckSphere")
        .FirstOrDefault()       // The first method is the variation we are looking for
    );
    // Plugin.Logger.LogInfo(il.ToString()); // uncomment to print the modified IL code to console
}
```